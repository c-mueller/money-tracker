// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"icekalt.dev/money-tracker/ent/apitoken"
	"icekalt.dev/money-tracker/ent/category"
	"icekalt.dev/money-tracker/ent/household"
	"icekalt.dev/money-tracker/ent/predicate"
	"icekalt.dev/money-tracker/ent/recurringexpense"
	"icekalt.dev/money-tracker/ent/transaction"
	"icekalt.dev/money-tracker/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIToken         = "APIToken"
	TypeCategory         = "Category"
	TypeHousehold        = "Household"
	TypeRecurringExpense = "RecurringExpense"
	TypeTransaction      = "Transaction"
	TypeUser             = "User"
)

// APITokenMutation represents an operation that mutates the APIToken nodes in the graph.
type APITokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	token_hash    *string
	expires_at    *time.Time
	last_used     *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*APIToken, error)
	predicates    []predicate.APIToken
}

var _ ent.Mutation = (*APITokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*APITokenMutation)

// newAPITokenMutation creates new mutation for the APIToken entity.
func newAPITokenMutation(c config, op Op, opts ...apitokenOption) *APITokenMutation {
	m := &APITokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPITokenID sets the ID field of the mutation.
func withAPITokenID(id int) apitokenOption {
	return func(m *APITokenMutation) {
		var (
			err   error
			once  sync.Once
			value *APIToken
		)
		m.oldValue = func(ctx context.Context) (*APIToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIToken sets the old APIToken of the mutation.
func withAPIToken(node *APIToken) apitokenOption {
	return func(m *APITokenMutation) {
		m.oldValue = func(context.Context) (*APIToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APITokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APITokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APITokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APITokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *APITokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APITokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APITokenMutation) ResetName() {
	m.name = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *APITokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *APITokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *APITokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *APITokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APITokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APITokenMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apitoken.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APITokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APITokenMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apitoken.FieldExpiresAt)
}

// SetLastUsed sets the "last_used" field.
func (m *APITokenMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *APITokenMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *APITokenMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[apitoken.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *APITokenMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *APITokenMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, apitoken.FieldLastUsed)
}

// SetCreatedAt sets the "created_at" field.
func (m *APITokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APITokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APITokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *APITokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *APITokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APITokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *APITokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APITokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APITokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APITokenMutation builder.
func (m *APITokenMutation) Where(ps ...predicate.APIToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APITokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APITokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APITokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APITokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIToken).
func (m *APITokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APITokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, apitoken.FieldName)
	}
	if m.token_hash != nil {
		fields = append(fields, apitoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, apitoken.FieldExpiresAt)
	}
	if m.last_used != nil {
		fields = append(fields, apitoken.FieldLastUsed)
	}
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APITokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldName:
		return m.Name()
	case apitoken.FieldTokenHash:
		return m.TokenHash()
	case apitoken.FieldExpiresAt:
		return m.ExpiresAt()
	case apitoken.FieldLastUsed:
		return m.LastUsed()
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APITokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldName:
		return m.OldName(ctx)
	case apitoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case apitoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apitoken.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case apitoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apitoken.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APITokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APITokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APITokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldExpiresAt) {
		fields = append(fields, apitoken.FieldExpiresAt)
	}
	if m.FieldCleared(apitoken.FieldLastUsed) {
		fields = append(fields, apitoken.FieldLastUsed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APITokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APITokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apitoken.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	}
	return fmt.Errorf("unknown APIToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APITokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldName:
		m.ResetName()
		return nil
	case apitoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case apitoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apitoken.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APITokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APITokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APITokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APITokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APITokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APITokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APITokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APITokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIToken edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	icon                      *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	household                 *int
	clearedhousehold          bool
	transactions              map[int]struct{}
	removedtransactions       map[int]struct{}
	clearedtransactions       bool
	recurring_expenses        map[int]struct{}
	removedrecurring_expenses map[int]struct{}
	clearedrecurring_expenses bool
	done                      bool
	oldValue                  func(context.Context) (*Category, error)
	predicates                []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *CategoryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CategoryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CategoryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[category.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CategoryMutation) IconCleared() bool {
	_, ok := m.clearedFields[category.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CategoryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, category.FieldIcon)
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHouseholdID sets the "household" edge to the Household entity by id.
func (m *CategoryMutation) SetHouseholdID(id int) {
	m.household = &id
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *CategoryMutation) ClearHousehold() {
	m.clearedhousehold = true
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *CategoryMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdID returns the "household" edge ID in the mutation.
func (m *CategoryMutation) HouseholdID() (id int, exists bool) {
	if m.household != nil {
		return *m.household, true
	}
	return
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *CategoryMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *CategoryMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *CategoryMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *CategoryMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *CategoryMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *CategoryMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *CategoryMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *CategoryMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddRecurringExpenseIDs adds the "recurring_expenses" edge to the RecurringExpense entity by ids.
func (m *CategoryMutation) AddRecurringExpenseIDs(ids ...int) {
	if m.recurring_expenses == nil {
		m.recurring_expenses = make(map[int]struct{})
	}
	for i := range ids {
		m.recurring_expenses[ids[i]] = struct{}{}
	}
}

// ClearRecurringExpenses clears the "recurring_expenses" edge to the RecurringExpense entity.
func (m *CategoryMutation) ClearRecurringExpenses() {
	m.clearedrecurring_expenses = true
}

// RecurringExpensesCleared reports if the "recurring_expenses" edge to the RecurringExpense entity was cleared.
func (m *CategoryMutation) RecurringExpensesCleared() bool {
	return m.clearedrecurring_expenses
}

// RemoveRecurringExpenseIDs removes the "recurring_expenses" edge to the RecurringExpense entity by IDs.
func (m *CategoryMutation) RemoveRecurringExpenseIDs(ids ...int) {
	if m.removedrecurring_expenses == nil {
		m.removedrecurring_expenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recurring_expenses, ids[i])
		m.removedrecurring_expenses[ids[i]] = struct{}{}
	}
}

// RemovedRecurringExpenses returns the removed IDs of the "recurring_expenses" edge to the RecurringExpense entity.
func (m *CategoryMutation) RemovedRecurringExpensesIDs() (ids []int) {
	for id := range m.removedrecurring_expenses {
		ids = append(ids, id)
	}
	return
}

// RecurringExpensesIDs returns the "recurring_expenses" edge IDs in the mutation.
func (m *CategoryMutation) RecurringExpensesIDs() (ids []int) {
	for id := range m.recurring_expenses {
		ids = append(ids, id)
	}
	return
}

// ResetRecurringExpenses resets all changes to the "recurring_expenses" edge.
func (m *CategoryMutation) ResetRecurringExpenses() {
	m.recurring_expenses = nil
	m.clearedrecurring_expenses = false
	m.removedrecurring_expenses = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, category.FieldIcon)
	}
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldIcon:
		return m.Icon()
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldIcon:
		return m.OldIcon(ctx)
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldIcon) {
		fields = append(fields, category.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldIcon:
		m.ResetIcon()
		return nil
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.household != nil {
		edges = append(edges, category.EdgeHousehold)
	}
	if m.transactions != nil {
		edges = append(edges, category.EdgeTransactions)
	}
	if m.recurring_expenses != nil {
		edges = append(edges, category.EdgeRecurringExpenses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeRecurringExpenses:
		ids := make([]ent.Value, 0, len(m.recurring_expenses))
		for id := range m.recurring_expenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransactions != nil {
		edges = append(edges, category.EdgeTransactions)
	}
	if m.removedrecurring_expenses != nil {
		edges = append(edges, category.EdgeRecurringExpenses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeRecurringExpenses:
		ids := make([]ent.Value, 0, len(m.removedrecurring_expenses))
		for id := range m.removedrecurring_expenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhousehold {
		edges = append(edges, category.EdgeHousehold)
	}
	if m.clearedtransactions {
		edges = append(edges, category.EdgeTransactions)
	}
	if m.clearedrecurring_expenses {
		edges = append(edges, category.EdgeRecurringExpenses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeHousehold:
		return m.clearedhousehold
	case category.EdgeTransactions:
		return m.clearedtransactions
	case category.EdgeRecurringExpenses:
		return m.clearedrecurring_expenses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeHousehold:
		m.ClearHousehold()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case category.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case category.EdgeRecurringExpenses:
		m.ResetRecurringExpenses()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// HouseholdMutation represents an operation that mutates the Household nodes in the graph.
type HouseholdMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	currency                  *string
	icon                      *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *int
	clearedowner              bool
	categories                map[int]struct{}
	removedcategories         map[int]struct{}
	clearedcategories         bool
	transactions              map[int]struct{}
	removedtransactions       map[int]struct{}
	clearedtransactions       bool
	recurring_expenses        map[int]struct{}
	removedrecurring_expenses map[int]struct{}
	clearedrecurring_expenses bool
	done                      bool
	oldValue                  func(context.Context) (*Household, error)
	predicates                []predicate.Household
}

var _ ent.Mutation = (*HouseholdMutation)(nil)

// householdOption allows management of the mutation configuration using functional options.
type householdOption func(*HouseholdMutation)

// newHouseholdMutation creates new mutation for the Household entity.
func newHouseholdMutation(c config, op Op, opts ...householdOption) *HouseholdMutation {
	m := &HouseholdMutation{
		config:        c,
		op:            op,
		typ:           TypeHousehold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHouseholdID sets the ID field of the mutation.
func withHouseholdID(id int) householdOption {
	return func(m *HouseholdMutation) {
		var (
			err   error
			once  sync.Once
			value *Household
		)
		m.oldValue = func(ctx context.Context) (*Household, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Household.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHousehold sets the old Household of the mutation.
func withHousehold(node *Household) householdOption {
	return func(m *HouseholdMutation) {
		m.oldValue = func(context.Context) (*Household, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HouseholdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HouseholdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HouseholdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HouseholdMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Household.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HouseholdMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HouseholdMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HouseholdMutation) ResetName() {
	m.name = nil
}

// SetCurrency sets the "currency" field.
func (m *HouseholdMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *HouseholdMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *HouseholdMutation) ResetCurrency() {
	m.currency = nil
}

// SetIcon sets the "icon" field.
func (m *HouseholdMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *HouseholdMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *HouseholdMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[household.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *HouseholdMutation) IconCleared() bool {
	_, ok := m.clearedFields[household.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *HouseholdMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, household.FieldIcon)
}

// SetCreatedAt sets the "created_at" field.
func (m *HouseholdMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HouseholdMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HouseholdMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HouseholdMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HouseholdMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HouseholdMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *HouseholdMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *HouseholdMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *HouseholdMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *HouseholdMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *HouseholdMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *HouseholdMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *HouseholdMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *HouseholdMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *HouseholdMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *HouseholdMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *HouseholdMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *HouseholdMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *HouseholdMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *HouseholdMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *HouseholdMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *HouseholdMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *HouseholdMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *HouseholdMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *HouseholdMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *HouseholdMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddRecurringExpenseIDs adds the "recurring_expenses" edge to the RecurringExpense entity by ids.
func (m *HouseholdMutation) AddRecurringExpenseIDs(ids ...int) {
	if m.recurring_expenses == nil {
		m.recurring_expenses = make(map[int]struct{})
	}
	for i := range ids {
		m.recurring_expenses[ids[i]] = struct{}{}
	}
}

// ClearRecurringExpenses clears the "recurring_expenses" edge to the RecurringExpense entity.
func (m *HouseholdMutation) ClearRecurringExpenses() {
	m.clearedrecurring_expenses = true
}

// RecurringExpensesCleared reports if the "recurring_expenses" edge to the RecurringExpense entity was cleared.
func (m *HouseholdMutation) RecurringExpensesCleared() bool {
	return m.clearedrecurring_expenses
}

// RemoveRecurringExpenseIDs removes the "recurring_expenses" edge to the RecurringExpense entity by IDs.
func (m *HouseholdMutation) RemoveRecurringExpenseIDs(ids ...int) {
	if m.removedrecurring_expenses == nil {
		m.removedrecurring_expenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recurring_expenses, ids[i])
		m.removedrecurring_expenses[ids[i]] = struct{}{}
	}
}

// RemovedRecurringExpenses returns the removed IDs of the "recurring_expenses" edge to the RecurringExpense entity.
func (m *HouseholdMutation) RemovedRecurringExpensesIDs() (ids []int) {
	for id := range m.removedrecurring_expenses {
		ids = append(ids, id)
	}
	return
}

// RecurringExpensesIDs returns the "recurring_expenses" edge IDs in the mutation.
func (m *HouseholdMutation) RecurringExpensesIDs() (ids []int) {
	for id := range m.recurring_expenses {
		ids = append(ids, id)
	}
	return
}

// ResetRecurringExpenses resets all changes to the "recurring_expenses" edge.
func (m *HouseholdMutation) ResetRecurringExpenses() {
	m.recurring_expenses = nil
	m.clearedrecurring_expenses = false
	m.removedrecurring_expenses = nil
}

// Where appends a list predicates to the HouseholdMutation builder.
func (m *HouseholdMutation) Where(ps ...predicate.Household) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HouseholdMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HouseholdMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Household, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HouseholdMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HouseholdMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Household).
func (m *HouseholdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HouseholdMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, household.FieldName)
	}
	if m.currency != nil {
		fields = append(fields, household.FieldCurrency)
	}
	if m.icon != nil {
		fields = append(fields, household.FieldIcon)
	}
	if m.created_at != nil {
		fields = append(fields, household.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, household.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HouseholdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case household.FieldName:
		return m.Name()
	case household.FieldCurrency:
		return m.Currency()
	case household.FieldIcon:
		return m.Icon()
	case household.FieldCreatedAt:
		return m.CreatedAt()
	case household.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HouseholdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case household.FieldName:
		return m.OldName(ctx)
	case household.FieldCurrency:
		return m.OldCurrency(ctx)
	case household.FieldIcon:
		return m.OldIcon(ctx)
	case household.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case household.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Household field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HouseholdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case household.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case household.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case household.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case household.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case household.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Household field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HouseholdMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HouseholdMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HouseholdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Household numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HouseholdMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(household.FieldIcon) {
		fields = append(fields, household.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HouseholdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HouseholdMutation) ClearField(name string) error {
	switch name {
	case household.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Household nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HouseholdMutation) ResetField(name string) error {
	switch name {
	case household.FieldName:
		m.ResetName()
		return nil
	case household.FieldCurrency:
		m.ResetCurrency()
		return nil
	case household.FieldIcon:
		m.ResetIcon()
		return nil
	case household.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case household.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Household field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HouseholdMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, household.EdgeOwner)
	}
	if m.categories != nil {
		edges = append(edges, household.EdgeCategories)
	}
	if m.transactions != nil {
		edges = append(edges, household.EdgeTransactions)
	}
	if m.recurring_expenses != nil {
		edges = append(edges, household.EdgeRecurringExpenses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HouseholdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case household.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case household.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeRecurringExpenses:
		ids := make([]ent.Value, 0, len(m.recurring_expenses))
		for id := range m.recurring_expenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HouseholdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcategories != nil {
		edges = append(edges, household.EdgeCategories)
	}
	if m.removedtransactions != nil {
		edges = append(edges, household.EdgeTransactions)
	}
	if m.removedrecurring_expenses != nil {
		edges = append(edges, household.EdgeRecurringExpenses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HouseholdMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case household.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeRecurringExpenses:
		ids := make([]ent.Value, 0, len(m.removedrecurring_expenses))
		for id := range m.removedrecurring_expenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HouseholdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, household.EdgeOwner)
	}
	if m.clearedcategories {
		edges = append(edges, household.EdgeCategories)
	}
	if m.clearedtransactions {
		edges = append(edges, household.EdgeTransactions)
	}
	if m.clearedrecurring_expenses {
		edges = append(edges, household.EdgeRecurringExpenses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HouseholdMutation) EdgeCleared(name string) bool {
	switch name {
	case household.EdgeOwner:
		return m.clearedowner
	case household.EdgeCategories:
		return m.clearedcategories
	case household.EdgeTransactions:
		return m.clearedtransactions
	case household.EdgeRecurringExpenses:
		return m.clearedrecurring_expenses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HouseholdMutation) ClearEdge(name string) error {
	switch name {
	case household.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Household unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HouseholdMutation) ResetEdge(name string) error {
	switch name {
	case household.EdgeOwner:
		m.ResetOwner()
		return nil
	case household.EdgeCategories:
		m.ResetCategories()
		return nil
	case household.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case household.EdgeRecurringExpenses:
		m.ResetRecurringExpenses()
		return nil
	}
	return fmt.Errorf("unknown Household edge %s", name)
}

// RecurringExpenseMutation represents an operation that mutates the RecurringExpense nodes in the graph.
type RecurringExpenseMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	amount           *string
	frequency        *string
	active           *bool
	start_date       *time.Time
	end_date         *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	household        *int
	clearedhousehold bool
	category         *int
	clearedcategory  bool
	done             bool
	oldValue         func(context.Context) (*RecurringExpense, error)
	predicates       []predicate.RecurringExpense
}

var _ ent.Mutation = (*RecurringExpenseMutation)(nil)

// recurringexpenseOption allows management of the mutation configuration using functional options.
type recurringexpenseOption func(*RecurringExpenseMutation)

// newRecurringExpenseMutation creates new mutation for the RecurringExpense entity.
func newRecurringExpenseMutation(c config, op Op, opts ...recurringexpenseOption) *RecurringExpenseMutation {
	m := &RecurringExpenseMutation{
		config:        c,
		op:            op,
		typ:           TypeRecurringExpense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecurringExpenseID sets the ID field of the mutation.
func withRecurringExpenseID(id int) recurringexpenseOption {
	return func(m *RecurringExpenseMutation) {
		var (
			err   error
			once  sync.Once
			value *RecurringExpense
		)
		m.oldValue = func(ctx context.Context) (*RecurringExpense, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecurringExpense.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecurringExpense sets the old RecurringExpense of the mutation.
func withRecurringExpense(node *RecurringExpense) recurringexpenseOption {
	return func(m *RecurringExpenseMutation) {
		m.oldValue = func(context.Context) (*RecurringExpense, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecurringExpenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecurringExpenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecurringExpenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecurringExpenseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecurringExpense.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RecurringExpenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RecurringExpenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RecurringExpenseMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RecurringExpenseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RecurringExpenseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RecurringExpenseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[recurringexpense.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RecurringExpenseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[recurringexpense.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RecurringExpenseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, recurringexpense.FieldDescription)
}

// SetAmount sets the "amount" field.
func (m *RecurringExpenseMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *RecurringExpenseMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *RecurringExpenseMutation) ResetAmount() {
	m.amount = nil
}

// SetFrequency sets the "frequency" field.
func (m *RecurringExpenseMutation) SetFrequency(s string) {
	m.frequency = &s
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *RecurringExpenseMutation) Frequency() (r string, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldFrequency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *RecurringExpenseMutation) ResetFrequency() {
	m.frequency = nil
}

// SetActive sets the "active" field.
func (m *RecurringExpenseMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *RecurringExpenseMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *RecurringExpenseMutation) ResetActive() {
	m.active = nil
}

// SetStartDate sets the "start_date" field.
func (m *RecurringExpenseMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *RecurringExpenseMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *RecurringExpenseMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *RecurringExpenseMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *RecurringExpenseMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *RecurringExpenseMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[recurringexpense.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *RecurringExpenseMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[recurringexpense.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *RecurringExpenseMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, recurringexpense.FieldEndDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *RecurringExpenseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecurringExpenseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecurringExpenseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecurringExpenseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecurringExpenseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecurringExpense entity.
// If the RecurringExpense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringExpenseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecurringExpenseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHouseholdID sets the "household" edge to the Household entity by id.
func (m *RecurringExpenseMutation) SetHouseholdID(id int) {
	m.household = &id
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *RecurringExpenseMutation) ClearHousehold() {
	m.clearedhousehold = true
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *RecurringExpenseMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdID returns the "household" edge ID in the mutation.
func (m *RecurringExpenseMutation) HouseholdID() (id int, exists bool) {
	if m.household != nil {
		return *m.household, true
	}
	return
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *RecurringExpenseMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *RecurringExpenseMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *RecurringExpenseMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *RecurringExpenseMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *RecurringExpenseMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *RecurringExpenseMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *RecurringExpenseMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *RecurringExpenseMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the RecurringExpenseMutation builder.
func (m *RecurringExpenseMutation) Where(ps ...predicate.RecurringExpense) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecurringExpenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecurringExpenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecurringExpense, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecurringExpenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecurringExpenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecurringExpense).
func (m *RecurringExpenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecurringExpenseMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, recurringexpense.FieldName)
	}
	if m.description != nil {
		fields = append(fields, recurringexpense.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, recurringexpense.FieldAmount)
	}
	if m.frequency != nil {
		fields = append(fields, recurringexpense.FieldFrequency)
	}
	if m.active != nil {
		fields = append(fields, recurringexpense.FieldActive)
	}
	if m.start_date != nil {
		fields = append(fields, recurringexpense.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, recurringexpense.FieldEndDate)
	}
	if m.created_at != nil {
		fields = append(fields, recurringexpense.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recurringexpense.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecurringExpenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recurringexpense.FieldName:
		return m.Name()
	case recurringexpense.FieldDescription:
		return m.Description()
	case recurringexpense.FieldAmount:
		return m.Amount()
	case recurringexpense.FieldFrequency:
		return m.Frequency()
	case recurringexpense.FieldActive:
		return m.Active()
	case recurringexpense.FieldStartDate:
		return m.StartDate()
	case recurringexpense.FieldEndDate:
		return m.EndDate()
	case recurringexpense.FieldCreatedAt:
		return m.CreatedAt()
	case recurringexpense.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecurringExpenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recurringexpense.FieldName:
		return m.OldName(ctx)
	case recurringexpense.FieldDescription:
		return m.OldDescription(ctx)
	case recurringexpense.FieldAmount:
		return m.OldAmount(ctx)
	case recurringexpense.FieldFrequency:
		return m.OldFrequency(ctx)
	case recurringexpense.FieldActive:
		return m.OldActive(ctx)
	case recurringexpense.FieldStartDate:
		return m.OldStartDate(ctx)
	case recurringexpense.FieldEndDate:
		return m.OldEndDate(ctx)
	case recurringexpense.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recurringexpense.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecurringExpense field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringExpenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recurringexpense.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case recurringexpense.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case recurringexpense.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case recurringexpense.FieldFrequency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case recurringexpense.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case recurringexpense.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case recurringexpense.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case recurringexpense.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recurringexpense.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecurringExpense field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecurringExpenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecurringExpenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringExpenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecurringExpense numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecurringExpenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recurringexpense.FieldDescription) {
		fields = append(fields, recurringexpense.FieldDescription)
	}
	if m.FieldCleared(recurringexpense.FieldEndDate) {
		fields = append(fields, recurringexpense.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecurringExpenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecurringExpenseMutation) ClearField(name string) error {
	switch name {
	case recurringexpense.FieldDescription:
		m.ClearDescription()
		return nil
	case recurringexpense.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown RecurringExpense nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecurringExpenseMutation) ResetField(name string) error {
	switch name {
	case recurringexpense.FieldName:
		m.ResetName()
		return nil
	case recurringexpense.FieldDescription:
		m.ResetDescription()
		return nil
	case recurringexpense.FieldAmount:
		m.ResetAmount()
		return nil
	case recurringexpense.FieldFrequency:
		m.ResetFrequency()
		return nil
	case recurringexpense.FieldActive:
		m.ResetActive()
		return nil
	case recurringexpense.FieldStartDate:
		m.ResetStartDate()
		return nil
	case recurringexpense.FieldEndDate:
		m.ResetEndDate()
		return nil
	case recurringexpense.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recurringexpense.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecurringExpense field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecurringExpenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.household != nil {
		edges = append(edges, recurringexpense.EdgeHousehold)
	}
	if m.category != nil {
		edges = append(edges, recurringexpense.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecurringExpenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recurringexpense.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case recurringexpense.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecurringExpenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecurringExpenseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecurringExpenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhousehold {
		edges = append(edges, recurringexpense.EdgeHousehold)
	}
	if m.clearedcategory {
		edges = append(edges, recurringexpense.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecurringExpenseMutation) EdgeCleared(name string) bool {
	switch name {
	case recurringexpense.EdgeHousehold:
		return m.clearedhousehold
	case recurringexpense.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecurringExpenseMutation) ClearEdge(name string) error {
	switch name {
	case recurringexpense.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case recurringexpense.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown RecurringExpense unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecurringExpenseMutation) ResetEdge(name string) error {
	switch name {
	case recurringexpense.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case recurringexpense.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown RecurringExpense edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	amount           *string
	description      *string
	date             *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	household        *int
	clearedhousehold bool
	category         *int
	clearedcategory  bool
	done             bool
	oldValue         func(context.Context) (*Transaction, error)
	predicates       []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transaction.FieldDescription)
}

// SetDate sets the "date" field.
func (m *TransactionMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *TransactionMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TransactionMutation) ResetDate() {
	m.date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHouseholdID sets the "household" edge to the Household entity by id.
func (m *TransactionMutation) SetHouseholdID(id int) {
	m.household = &id
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *TransactionMutation) ClearHousehold() {
	m.clearedhousehold = true
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *TransactionMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdID returns the "household" edge ID in the mutation.
func (m *TransactionMutation) HouseholdID() (id int, exists bool) {
	if m.household != nil {
		return *m.household, true
	}
	return
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *TransactionMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *TransactionMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *TransactionMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *TransactionMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *TransactionMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *TransactionMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.date != nil {
		fields = append(fields, transaction.FieldDate)
	}
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldDescription:
		return m.Description()
	case transaction.FieldDate:
		return m.Date()
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	case transaction.FieldDate:
		return m.OldDate(ctx)
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transaction.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldDescription) {
		fields = append(fields, transaction.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	case transaction.FieldDate:
		m.ResetDate()
		return nil
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.household != nil {
		edges = append(edges, transaction.EdgeHousehold)
	}
	if m.category != nil {
		edges = append(edges, transaction.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhousehold {
		edges = append(edges, transaction.EdgeHousehold)
	}
	if m.clearedcategory {
		edges = append(edges, transaction.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeHousehold:
		return m.clearedhousehold
	case transaction.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case transaction.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case transaction.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	email             *string
	name              *string
	subject           *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	households        map[int]struct{}
	removedhouseholds map[int]struct{}
	clearedhouseholds bool
	api_tokens        map[int]struct{}
	removedapi_tokens map[int]struct{}
	clearedapi_tokens bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSubject sets the "subject" field.
func (m *UserMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *UserMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *UserMutation) ResetSubject() {
	m.subject = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddHouseholdIDs adds the "households" edge to the Household entity by ids.
func (m *UserMutation) AddHouseholdIDs(ids ...int) {
	if m.households == nil {
		m.households = make(map[int]struct{})
	}
	for i := range ids {
		m.households[ids[i]] = struct{}{}
	}
}

// ClearHouseholds clears the "households" edge to the Household entity.
func (m *UserMutation) ClearHouseholds() {
	m.clearedhouseholds = true
}

// HouseholdsCleared reports if the "households" edge to the Household entity was cleared.
func (m *UserMutation) HouseholdsCleared() bool {
	return m.clearedhouseholds
}

// RemoveHouseholdIDs removes the "households" edge to the Household entity by IDs.
func (m *UserMutation) RemoveHouseholdIDs(ids ...int) {
	if m.removedhouseholds == nil {
		m.removedhouseholds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.households, ids[i])
		m.removedhouseholds[ids[i]] = struct{}{}
	}
}

// RemovedHouseholds returns the removed IDs of the "households" edge to the Household entity.
func (m *UserMutation) RemovedHouseholdsIDs() (ids []int) {
	for id := range m.removedhouseholds {
		ids = append(ids, id)
	}
	return
}

// HouseholdsIDs returns the "households" edge IDs in the mutation.
func (m *UserMutation) HouseholdsIDs() (ids []int) {
	for id := range m.households {
		ids = append(ids, id)
	}
	return
}

// ResetHouseholds resets all changes to the "households" edge.
func (m *UserMutation) ResetHouseholds() {
	m.households = nil
	m.clearedhouseholds = false
	m.removedhouseholds = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the APIToken entity by ids.
func (m *UserMutation) AddAPITokenIDs(ids ...int) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the APIToken entity.
func (m *UserMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the APIToken entity was cleared.
func (m *UserMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the APIToken entity by IDs.
func (m *UserMutation) RemoveAPITokenIDs(ids ...int) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the APIToken entity.
func (m *UserMutation) RemovedAPITokensIDs() (ids []int) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *UserMutation) APITokensIDs() (ids []int) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *UserMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.subject != nil {
		fields = append(fields, user.FieldSubject)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldSubject:
		return m.Subject()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSubject:
		return m.OldSubject(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSubject:
		m.ResetSubject()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.households != nil {
		edges = append(edges, user.EdgeHouseholds)
	}
	if m.api_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeHouseholds:
		ids := make([]ent.Value, 0, len(m.households))
		for id := range m.households {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhouseholds != nil {
		edges = append(edges, user.EdgeHouseholds)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeHouseholds:
		ids := make([]ent.Value, 0, len(m.removedhouseholds))
		for id := range m.removedhouseholds {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhouseholds {
		edges = append(edges, user.EdgeHouseholds)
	}
	if m.clearedapi_tokens {
		edges = append(edges, user.EdgeAPITokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeHouseholds:
		return m.clearedhouseholds
	case user.EdgeAPITokens:
		return m.clearedapi_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeHouseholds:
		m.ResetHouseholds()
		return nil
	case user.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
