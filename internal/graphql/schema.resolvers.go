package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"
	"time"

	"icekalt.dev/money-tracker/internal/domain"
	"icekalt.dev/money-tracker/internal/graphql/model"
)

// CreateHousehold is the resolver for the createHousehold field.
func (r *mutationResolver) CreateHousehold(ctx context.Context, input model.CreateHouseholdInput) (*model.Household, error) {
	h, err := r.HouseholdSvc.Create(ctx, input.Name, derefString(input.Description), input.Currency, derefString(input.Icon))
	if err != nil {
		return nil, err
	}
	return toGQLHousehold(h), nil
}

// UpdateHousehold is the resolver for the updateHousehold field.
func (r *mutationResolver) UpdateHousehold(ctx context.Context, input model.UpdateHouseholdInput) (*model.Household, error) {
	h, err := r.HouseholdSvc.Update(ctx, input.ID, input.Name, derefString(input.Description), input.Currency, derefString(input.Icon))
	if err != nil {
		return nil, err
	}
	return toGQLHousehold(h), nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	cat, err := r.CategorySvc.Create(ctx, input.HouseholdID, input.Name, derefString(input.Icon))
	if err != nil {
		return nil, err
	}
	return toGQLCategory(cat), nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input model.UpdateCategoryInput) (*model.Category, error) {
	cat, err := r.CategorySvc.Update(ctx, input.ID, input.Name, derefString(input.Icon))
	if err != nil {
		return nil, err
	}
	return toGQLCategory(cat), nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.CreateTransactionInput) (*model.Transaction, error) {
	amount, err := domain.NewMoney(input.Amount)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid amount", domain.ErrValidation)
	}

	date, err := time.Parse("2006-01-02", input.Date)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid date format, expected YYYY-MM-DD", domain.ErrValidation)
	}

	tx, err := r.TransactionSvc.Create(ctx, input.HouseholdID, input.CategoryID, amount, derefString(input.Description), date)
	if err != nil {
		return nil, err
	}
	return toGQLTransaction(tx), nil
}

// UpdateTransaction is the resolver for the updateTransaction field.
func (r *mutationResolver) UpdateTransaction(ctx context.Context, input model.UpdateTransactionInput) (*model.Transaction, error) {
	amount, err := domain.NewMoney(input.Amount)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid amount", domain.ErrValidation)
	}

	date, err := time.Parse("2006-01-02", input.Date)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid date format, expected YYYY-MM-DD", domain.ErrValidation)
	}

	tx, err := r.TransactionSvc.Update(ctx, input.HouseholdID, input.ID, input.CategoryID, amount, derefString(input.Description), date)
	if err != nil {
		return nil, err
	}
	return toGQLTransaction(tx), nil
}

// CreateRecurringExpense is the resolver for the createRecurringExpense field.
func (r *mutationResolver) CreateRecurringExpense(ctx context.Context, input model.CreateRecurringExpenseInput) (*model.RecurringExpense, error) {
	amount, err := domain.NewMoney(input.Amount)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid amount", domain.ErrValidation)
	}

	freq := domain.Frequency(input.Frequency)
	if err := freq.Validate(); err != nil {
		return nil, err
	}

	startDate, err := time.Parse("2006-01-02", input.StartDate)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid start_date format", domain.ErrValidation)
	}

	var endDate *time.Time
	if input.EndDate != nil {
		t, err := time.Parse("2006-01-02", *input.EndDate)
		if err != nil {
			return nil, fmt.Errorf("%w: invalid end_date format", domain.ErrValidation)
		}
		endDate = &t
	}

	re, err := r.RecurringExpenseSvc.Create(ctx, input.HouseholdID, input.CategoryID, input.Name, derefString(input.Description), amount, freq, startDate, endDate)
	if err != nil {
		return nil, err
	}
	return toGQLRecurringExpense(re), nil
}

// UpdateRecurringExpense is the resolver for the updateRecurringExpense field.
func (r *mutationResolver) UpdateRecurringExpense(ctx context.Context, input model.UpdateRecurringExpenseInput) (*model.RecurringExpense, error) {
	amount, err := domain.NewMoney(input.Amount)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid amount", domain.ErrValidation)
	}

	freq := domain.Frequency(input.Frequency)
	if err := freq.Validate(); err != nil {
		return nil, err
	}

	startDate, err := time.Parse("2006-01-02", input.StartDate)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid start_date format", domain.ErrValidation)
	}

	var endDate *time.Time
	if input.EndDate != nil {
		t, err := time.Parse("2006-01-02", *input.EndDate)
		if err != nil {
			return nil, fmt.Errorf("%w: invalid end_date format", domain.ErrValidation)
		}
		endDate = &t
	}

	re, err := r.RecurringExpenseSvc.Update(ctx, input.ID, input.CategoryID, input.Name, derefString(input.Description), amount, freq, input.Active, startDate, endDate)
	if err != nil {
		return nil, err
	}
	return toGQLRecurringExpense(re), nil
}

// Households is the resolver for the households field.
func (r *queryResolver) Households(ctx context.Context) ([]model.Household, error) {
	households, err := r.HouseholdSvc.List(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]model.Household, len(households))
	for i, h := range households {
		result[i] = *toGQLHousehold(h)
	}
	return result, nil
}

// Household is the resolver for the household field.
func (r *queryResolver) Household(ctx context.Context, id int) (*model.Household, error) {
	h, err := r.HouseholdSvc.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return toGQLHousehold(h), nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, householdID int) ([]model.Category, error) {
	categories, err := r.CategorySvc.List(ctx, householdID)
	if err != nil {
		return nil, err
	}

	result := make([]model.Category, len(categories))
	for i, c := range categories {
		result[i] = *toGQLCategory(c)
	}
	return result, nil
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context, householdID int, month string) ([]model.Transaction, error) {
	t, err := time.Parse("2006-01", month)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid month format, expected YYYY-MM", domain.ErrValidation)
	}

	transactions, err := r.TransactionSvc.ListByMonth(ctx, householdID, t.Year(), t.Month())
	if err != nil {
		return nil, err
	}

	result := make([]model.Transaction, len(transactions))
	for i, tx := range transactions {
		result[i] = *toGQLTransaction(tx)
	}
	return result, nil
}

// RecurringExpenses is the resolver for the recurringExpenses field.
func (r *queryResolver) RecurringExpenses(ctx context.Context, householdID int) ([]model.RecurringExpense, error) {
	expenses, err := r.RecurringExpenseSvc.List(ctx, householdID)
	if err != nil {
		return nil, err
	}

	result := make([]model.RecurringExpense, len(expenses))
	for i, re := range expenses {
		result[i] = *toGQLRecurringExpense(re)
	}
	return result, nil
}

// MonthlySummary is the resolver for the monthlySummary field.
func (r *queryResolver) MonthlySummary(ctx context.Context, householdID int, month string) (*model.MonthlySummary, error) {
	t, err := time.Parse("2006-01", month)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid month format, expected YYYY-MM", domain.ErrValidation)
	}

	summary, err := r.SummarySvc.GetMonthlySummary(ctx, householdID, t.Year(), t.Month())
	if err != nil {
		return nil, err
	}
	return toGQLMonthlySummary(summary), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
